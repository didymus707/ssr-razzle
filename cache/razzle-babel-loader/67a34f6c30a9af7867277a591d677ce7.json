{"ast":null,"code":"var _jsxFileName = \"/Users/okechukwuiheagwara/Documents/Adewale/simpu/razzle/with-typescript/src/app/authenticated-app/inbox/components/messages/ConversationThread.tsx\";\nvar __jsx = React.createElement;\nimport { Flex, Image, Stack, useDisclosure } from '@chakra-ui/core';\nimport { isEmpty } from 'lodash';\nimport React, { useState } from 'react';\nimport { useQuery } from 'react-query';\nimport { getThreadByID } from '../../inbox.service';\nimport noConversationImage from '../no-conversation.svg';\nimport { useInbox } from '../Provider';\nimport { ConversationThreadContent } from './ConversationThreadContent';\nimport { ConversationThreadFooter } from './ConversationThreadFooter';\nimport { ConversationThreadHeader } from './ConversationThreadHeader';\nimport { ThreadStarter } from './ThreadStarter';\nexport const ConversationThread = props => {\n  var _channels$filter;\n\n  const {\n    tags,\n    hasMore,\n    messages,\n    channels,\n    isFetching,\n    setActiveFilter,\n    onFetchMoreData,\n    setActiveThread,\n    thread: threadProps = {}\n  } = props;\n  const {\n    isNewConversation\n  } = useInbox();\n  const {\n    isOpen: showEmailCompose,\n    onOpen: onOpenEmailCompose,\n    onClose: onCloseEmailCompose\n  } = useDisclosure();\n  const {\n    0: text,\n    1: setText\n  } = useState('');\n  const {\n    0: lastMessage,\n    1: setLastMessage\n  } = useState(threadProps.last_message);\n  const {\n    0: shouldShowStarterCompose,\n    1: setShouldShowStarterCompose\n  } = useState(false);\n  const {\n    0: twoWayPayload,\n    1: setTwoWayPayload\n  } = useState({\n    senderPlatformNick: ''\n  });\n  const {\n    data: thread\n  } = useQuery(['threads', threadProps.uuid], () => getThreadByID({\n    thread_id: threadProps.uuid\n  }), {\n    initialData: threadProps,\n    enabled: !!threadProps.uuid\n  });\n\n  const handleTextChange = (text, isTemplateMode) => {\n    setText(text);\n  };\n\n  const handleEmailReply = message => {\n    onOpenEmailCompose();\n    setLastMessage(message);\n  };\n\n  const handleEmailReplyAll = message => {\n    onOpenEmailCompose();\n    setLastMessage(message);\n  };\n\n  const handleEmailForward = message => {\n    onOpenEmailCompose();\n    setLastMessage(message);\n  };\n\n  return isNewConversation ? __jsx(React.Fragment, null, __jsx(ThreadStarter, {\n    flex: \"1\",\n    text: text,\n    channels: (_channels$filter = channels === null || channels === void 0 ? void 0 : channels.filter(channel => channel.user.channel_name === 'email' || channel.user.channel_name === 'phone')) !== null && _channels$filter !== void 0 ? _channels$filter : [],\n    setText: handleTextChange,\n    twoWayPayload: twoWayPayload,\n    setActiveFilter: setActiveFilter,\n    setActiveThread: setActiveThread,\n    setTwoWayPayload: setTwoWayPayload,\n    showCompose: shouldShowStarterCompose,\n    setShowCompose: setShouldShowStarterCompose,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 86,\n      columnNumber: 7\n    }\n  })) : __jsx(Stack, {\n    pt: \"1.5rem\",\n    px: \"1.5rem\",\n    bg: \"white\",\n    height: \"calc(100vh - 60px)\",\n    flex: 1,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 105,\n      columnNumber: 5\n    }\n  }, (thread === null || thread === void 0 ? void 0 : thread.state) === 'queued' || isEmpty(thread) ? __jsx(Flex, {\n    height: \"100%\",\n    justifyContent: \"center\",\n    alignItems: \"center\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 107,\n      columnNumber: 9\n    }\n  }, __jsx(Image, {\n    src: noConversationImage,\n    size: \"15rem\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 108,\n      columnNumber: 11\n    }\n  })) : __jsx(React.Fragment, null, __jsx(ConversationThreadHeader, {\n    tags: tags,\n    thread: thread,\n    lastMessage: threadProps === null || threadProps === void 0 ? void 0 : threadProps.last_message,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 112,\n      columnNumber: 11\n    }\n  }), __jsx(ConversationThreadContent, {\n    thread,\n    hasMore,\n    messages,\n    isFetching,\n    onFetchMoreData,\n    onEmailReply: handleEmailReply,\n    onEmailForward: handleEmailForward,\n    onEmailReplyAll: handleEmailReplyAll,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 117,\n      columnNumber: 11\n    }\n  }), (thread === null || thread === void 0 ? void 0 : thread.state) !== 'resolved' && __jsx(ConversationThreadFooter, {\n    thread: thread,\n    lastMessage: lastMessage,\n    twoWayPayload: twoWayPayload,\n    showEmailCompose: showEmailCompose,\n    onCloseEmailCompose: onCloseEmailCompose,\n    setTwoWayPayload: setTwoWayPayload,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 130,\n      columnNumber: 13\n    }\n  })));\n}; // import {\n//   Badge,\n//   Box, Flex, IconButton, Spinner, Text\n// } from '@chakra-ui/core';\n// import React, { createRef, RefObject, useEffect, useRef, useState } from 'react';\n// import { useDispatch, useSelector } from 'react-redux';\n// import { useHistory, useParams } from 'react-router-dom';\n// import InfiniteScroll from \"react-infinite-scroll-component\";\n// import { RootState } from '../../../../../root';\n// import { selectOrganisationID, selectUserID } from '../../../../unauthenticated-app/authentication';\n// import { INBOX_INIT } from '../../inbox.data';\n// import { ConversationThreadProps } from '../../inbox.types';\n// import {\n//   fetchThreadMessages, selectFirstUnreadMessageID, selectLoadingMessageIDs, selectMessageMeta,\n//   selectScrollTop, selectThreadDetailByID, selectThreadMessageIDs, selectThreadUnreadCount, updateScrollTop\n// } from '../../slices';\n// import { LoadingMessageItem } from './LoadingMessageItem';\n// import { MessageItem } from './MessageItem';\n// export function ConversationThread({ threadRef, ...rest }: ConversationThreadProps) {\n//   const dispatch = useDispatch();\n//   const history = useHistory();\n//   const params = useParams<{ id: string }>();\n//   const paramsID = params.id === 'new' ? '' : params.id;\n//   const currentThread = useSelector(\n//     (state: RootState) => selectThreadDetailByID(state, paramsID)\n//   ) || INBOX_INIT.thread;\n//   const scrollTop = useSelector(\n//     (state: RootState) => selectScrollTop(state, { thread_id: paramsID })\n//   ) || 0;\n//   const { uuid: currentThreadID } = currentThread;\n//   const user_id = useSelector(selectUserID);\n//   const organisation_id = useSelector(selectOrganisationID);\n//   const threadMessageIDs = useSelector(\n//     (state: RootState) => selectThreadMessageIDs(state, currentThreadID)\n//   );\n//   const lastMessageRef = useRef<HTMLDivElement>(null);\n//   const messageItemRefs = threadMessageIDs.reduce(\n//     (acc: { [k: string]: RefObject<HTMLElement> }, item, index) => {\n//       if (item) {\n//         if (index === threadMessageIDs.length - 1) {\n//           acc[item] = lastMessageRef;\n//         } else {\n//           acc[item] = createRef<HTMLElement>();\n//         }\n//       }\n//       return acc;\n//     },\n//     {},\n//   );\n//   const loadingMessageIDs = useSelector(\n//     (state: RootState) => selectLoadingMessageIDs(state, { thread_id: paramsID })\n//   );\n//   const messageIDs = [\n//     ...loadingMessageIDs.map(id => ({ id, isLoading: true })),\n//     ...threadMessageIDs.map(id => ({ id, isLoading: false })),\n//   ].flat();\n//   const threadMessageMeta = useSelector(\n//     (state: RootState) => selectMessageMeta(state, { thread_id: currentThreadID })\n//   );\n//   const [hasMore, setHasMore] = useState(true);\n//   const [isScrollBtnDisplayed, setIsScrollBtnDisplayed] = useState(false);\n//   const threadMessageUnreadCount = useSelector(\n//     (state: RootState) => selectThreadUnreadCount(state, {\n//       thread_id: currentThreadID, author_id: user_id || ''\n//     })\n//   ) || 0;\n//   const firstUnreadMessgeID = useSelector(\n//     (state: RootState) => selectFirstUnreadMessageID(state, { thread_id: currentThreadID })\n//   );\n//   const fetchMoreData = () => {\n//     const { count = 0, page = 0 } = threadMessageMeta.meta || {};\n//     if (count !== 0 && Math.ceil((count / 15) - page) === 0) {\n//       return setHasMore(false);\n//     }\n//     return currentThreadID && currentThreadID !== 'start' && !currentThreadID.includes('unknown') && user_id\n//       && organisation_id && dispatch(fetchThreadMessages({\n//         page: page + 1,\n//         thread_id: currentThreadID,\n//       }));\n//   }\n//   const handleOnScroll = (st: number) => {\n//     if (threadRef && threadRef.current && lastMessageRef && lastMessageRef.current) {\n//       threadRef.current.dataset.scrollTop = st.toString();\n//       threadRef.current.dataset.currentThreadID = currentThreadID;\n//       const diff = lastMessageRef.current.scrollHeight + (st || 0);\n//       setIsScrollBtnDisplayed(diff <= 0);\n//     }\n//   }\n//   const handleScrollBtnClick = () => {\n//     if (threadMessageUnreadCount > 0) {\n//       if (firstUnreadMessgeID) {\n//         const view = messageItemRefs[firstUnreadMessgeID || ''];\n//         if (view && view.current) {\n//           view.current.scrollIntoView({\n//             behavior: 'smooth',\n//             block: 'center',\n//           });\n//         }\n//       }\n//     } else if (threadRef && threadRef.current) {\n//       threadRef.current.scrollTop = 0;\n//     }\n//   };\n//   // const [forceRerender, setForceRerender] = useState(0);\n//   // manage scroll\n//   useEffect(() => {\n//     if (threadRef && threadRef.current) {\n//       // eslint-disable-next-line @typescript-eslint/no-unused-vars\n//       const { scrollHeight, clientHeight } = threadRef.current;\n//       const diff = scrollTop + scrollHeight;\n//       // if (forceRerender > 0 && scrollHeight === clientHeight) {\n//       //   return setForceRerender(0);\n//       // }\n//       if (diff < 0) {\n//         // const nextForceRerender = forceRerender + 1;\n//         // threadRef.current.scrollTop = -(nextForceRerender * clientHeight);\n//         // return setForceRerender(nextForceRerender);\n//       }\n//       threadRef.current.scrollTop = 0;\n//       // if (forceRerender !== 0) {\n//       //   setForceRerender(0);\n//       // }\n//     }\n//     // }, [paramsID, scrollTop, forceRerender]);\n//     // eslint-disable-next-line react-hooks/exhaustive-deps\n//   }, [paramsID, scrollTop]);\n//   // fetch the conversation messages\n//   useEffect(() => {\n//     setHasMore(true);\n//     fetchMoreData();\n//     // eslint-disable-next-line react-hooks/exhaustive-deps\n//   }, [currentThreadID]);\n//   useEffect(() => {\n//     return history.listen(() => {\n//       if (threadRef?.current) {\n//         const {\n//           scrollTop: trScrollTop = '0', currentThreadID: trCurrentThreadID = ''\n//         } = threadRef.current.dataset || {};\n//         const scrollTop = Number(trScrollTop);\n//         if (trCurrentThreadID && scrollTop < 0) {\n//           dispatch(updateScrollTop({ thread_id: trCurrentThreadID, scrollTop }));\n//         }\n//         threadRef.current.dataset.scrollTop = '0';\n//       }\n//     })\n//     // eslint-disable-next-line react-hooks/exhaustive-deps\n//   }, [history]);\n//   return (\n//     <Flex\n//       overflowY=\"hidden\"\n//       flexDirection=\"column\"\n//       {...rest}\n//     >\n//       <Flex\n//         flexDirection=\"column-reverse\"\n//         overflowY=\"scroll\"\n//         flex={1}\n//         className=\"thread\"\n//         id=\"message-thread-scrollable\"\n//         pt=\"0\"\n//         px={['1rem', '1rem', '2.5rem', '2.5rem']}\n//         ref={threadRef}\n//         onScroll={(e: any) => handleOnScroll(e.target.scrollTop)}\n//       >\n//         <InfiniteScroll\n//           dataLength={messageIDs.length}\n//           next={fetchMoreData}\n//           style={{ display: 'flex', flexDirection: 'column-reverse', paddingBottom: '.75rem' }}\n//           inverse={true}\n//           hasMore={hasMore}\n//           loader={(\n//             <Box textAlign=\"center\" paddingTop=\"2rem\">\n//               <Spinner color=\"blue.500\" size=\"md\" />\n//             </Box>\n//           )}\n//           scrollableTarget=\"message-thread-scrollable\"\n//         >\n//           {messageIDs.map(({ id, isLoading }, index) => (\n//             <Box key={id} width=\"100%\" marginTop=\"1rem\" ref={messageItemRefs[id]}>\n//               {id === threadMessageMeta.firstUnreadMessageID && index !== 0 && (\n//                 <Flex marginY=\"1rem\" alignItems=\"center\">\n//                   <Box height=\"1px\" backgroundColor=\"#E2E8F0\" flex={1} />\n//                   <Text marginX=\"0.5rem\" fontSize=\".75rem\" fontStyle=\"italic\" color=\"red.500\">New</Text>\n//                   <Box height=\"1px\" backgroundColor=\"#E2E8F0\" flex={1} />\n//                 </Flex>\n//               )}\n//               {isLoading ? (\n//                 <LoadingMessageItem\n//                   messageRef={messageItemRefs[id]}\n//                   previousItemID={threadMessageIDs[index - 1]}\n//                   nextItemID={threadMessageIDs[index + 1]}\n//                   threadSenderID={currentThread.sender_id}\n//                   itemID={id}\n//                 />\n//               ) : (\n//                 <MessageItem\n//                   messageRef={messageItemRefs[id]}\n//                   previousItemID={threadMessageIDs[index - 1]}\n//                   nextItemID={threadMessageIDs[index + 1]}\n//                   itemID={id}\n//                   threadSenderID={currentThread.sender_id}\n//                 />\n//               )}\n//             </Box>\n//           ))}\n//         </InfiniteScroll>\n//         {isScrollBtnDisplayed && (\n//           <Box\n//             position=\"absolute\"\n//             bottom=\"6rem\"\n//             right={['1rem', '1rem', '2.5rem', '2.5rem']}\n//           >\n//             <IconButton\n//               aria-label=\"scroll down\"\n//               icon=\"arrow-down\"\n//               size=\"md\"\n//               borderRadius=\"50%\"\n//               onClick={handleScrollBtnClick}\n//             />\n//             {threadMessageUnreadCount > 0 && (\n//               <Badge\n//                 variant=\"solid\"\n//                 variantColor=\"blue\"\n//                 borderRadius=\"50%\"\n//                 position=\"absolute\"\n//                 left=\"-.25rem\"\n//               >\n//                 {threadMessageUnreadCount}\n//               </Badge>\n//             )}\n//           </Box>\n//         )}\n//       </Flex>\n//     </Flex>\n//   );\n// }","map":{"version":3,"sources":["/Users/okechukwuiheagwara/Documents/Adewale/simpu/razzle/with-typescript/src/app/authenticated-app/inbox/components/messages/ConversationThread.tsx"],"names":["Flex","Image","Stack","useDisclosure","isEmpty","React","useState","useQuery","getThreadByID","noConversationImage","useInbox","ConversationThreadContent","ConversationThreadFooter","ConversationThreadHeader","ThreadStarter","ConversationThread","props","tags","hasMore","messages","channels","isFetching","setActiveFilter","onFetchMoreData","setActiveThread","thread","threadProps","isNewConversation","isOpen","showEmailCompose","onOpen","onOpenEmailCompose","onClose","onCloseEmailCompose","text","setText","lastMessage","setLastMessage","last_message","shouldShowStarterCompose","setShouldShowStarterCompose","twoWayPayload","setTwoWayPayload","senderPlatformNick","data","uuid","thread_id","initialData","enabled","handleTextChange","isTemplateMode","handleEmailReply","message","handleEmailReplyAll","handleEmailForward","filter","channel","user","channel_name","state","onEmailReply","onEmailForward","onEmailReplyAll"],"mappings":"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A;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import { Flex, Image, Stack, useDisclosure } from '@chakra-ui/core';\nimport { AxiosError } from 'axios';\nimport { isEmpty } from 'lodash';\nimport React, { useState } from 'react';\nimport { useQuery } from 'react-query';\nimport { getThreadByID } from '../../inbox.service';\nimport { ThreadSchema, TwoWayPayloadSchema } from '../../inbox.types';\nimport { ConversationFiltersProps } from '../filters';\nimport noConversationImage from '../no-conversation.svg';\nimport { useInbox } from '../Provider';\nimport {\n  ConversationThreadContent,\n  ConversationThreadContentProps,\n} from './ConversationThreadContent';\nimport { ConversationThreadFooter } from './ConversationThreadFooter';\nimport {\n  ConversationThreadHeader,\n  ConversationThreadHeaderProps,\n} from './ConversationThreadHeader';\nimport { ThreadStarter } from './ThreadStarter';\n\nexport type ConversationThreadUIProps = ConversationThreadHeaderProps &\n  ConversationThreadContentProps &\n  Pick<ConversationFiltersProps, 'channels'> & {\n    setActiveFilter?: () => void;\n    setActiveThread?: React.Dispatch<React.SetStateAction<ThreadSchema | undefined>>;\n  };\n\nexport const ConversationThread = (props: ConversationThreadUIProps) => {\n  const {\n    tags,\n    hasMore,\n    messages,\n    channels,\n    isFetching,\n    setActiveFilter,\n    onFetchMoreData,\n    setActiveThread,\n    thread: threadProps = {} as ThreadSchema,\n  } = props;\n\n  const { isNewConversation } = useInbox();\n  const {\n    isOpen: showEmailCompose,\n    onOpen: onOpenEmailCompose,\n    onClose: onCloseEmailCompose,\n  } = useDisclosure();\n\n  const [text, setText] = useState('');\n  const [lastMessage, setLastMessage] = useState(threadProps.last_message);\n  const [shouldShowStarterCompose, setShouldShowStarterCompose] = useState(false);\n  const [twoWayPayload, setTwoWayPayload] = useState<TwoWayPayloadSchema>({\n    senderPlatformNick: '',\n  });\n\n  const { data: thread } = useQuery<ThreadSchema, AxiosError>(\n    ['threads', threadProps.uuid],\n    () => getThreadByID({ thread_id: threadProps.uuid }),\n    {\n      initialData: threadProps,\n      enabled: !!threadProps.uuid,\n    },\n  );\n\n  const handleTextChange = (text: string, isTemplateMode?: boolean) => {\n    setText(text);\n  };\n\n  const handleEmailReply = (message: any) => {\n    onOpenEmailCompose();\n    setLastMessage(message);\n  };\n\n  const handleEmailReplyAll = (message: any) => {\n    onOpenEmailCompose();\n    setLastMessage(message);\n  };\n\n  const handleEmailForward = (message: any) => {\n    onOpenEmailCompose();\n    setLastMessage(message);\n  };\n\n  return isNewConversation ? (\n    <>\n      <ThreadStarter\n        flex=\"1\"\n        text={text}\n        channels={\n          channels?.filter(\n            (channel: any) =>\n              channel.user.channel_name === 'email' || channel.user.channel_name === 'phone',\n          ) ?? []\n        }\n        setText={handleTextChange}\n        twoWayPayload={twoWayPayload}\n        setActiveFilter={setActiveFilter}\n        setActiveThread={setActiveThread}\n        setTwoWayPayload={setTwoWayPayload as any}\n        showCompose={shouldShowStarterCompose}\n        setShowCompose={setShouldShowStarterCompose}\n      />\n    </>\n  ) : (\n    <Stack pt=\"1.5rem\" px=\"1.5rem\" bg=\"white\" height=\"calc(100vh - 60px)\" flex={1}>\n      {thread?.state === 'queued' || isEmpty(thread) ? (\n        <Flex height=\"100%\" justifyContent=\"center\" alignItems=\"center\">\n          <Image src={noConversationImage} size=\"15rem\" />\n        </Flex>\n      ) : (\n        <>\n          <ConversationThreadHeader\n            tags={tags}\n            thread={thread}\n            lastMessage={threadProps?.last_message}\n          />\n          <ConversationThreadContent\n            {...{\n              thread,\n              hasMore,\n              messages,\n              isFetching,\n              onFetchMoreData,\n              onEmailReply: handleEmailReply,\n              onEmailForward: handleEmailForward,\n              onEmailReplyAll: handleEmailReplyAll,\n            }}\n          />\n          {thread?.state !== 'resolved' && (\n            <ConversationThreadFooter\n              thread={thread}\n              lastMessage={lastMessage}\n              twoWayPayload={twoWayPayload}\n              showEmailCompose={showEmailCompose}\n              onCloseEmailCompose={onCloseEmailCompose}\n              setTwoWayPayload={setTwoWayPayload as any}\n            />\n          )}\n        </>\n      )}\n    </Stack>\n  );\n};\n\n// import {\n//   Badge,\n//   Box, Flex, IconButton, Spinner, Text\n// } from '@chakra-ui/core';\n// import React, { createRef, RefObject, useEffect, useRef, useState } from 'react';\n// import { useDispatch, useSelector } from 'react-redux';\n// import { useHistory, useParams } from 'react-router-dom';\n// import InfiniteScroll from \"react-infinite-scroll-component\";\n// import { RootState } from '../../../../../root';\n// import { selectOrganisationID, selectUserID } from '../../../../unauthenticated-app/authentication';\n// import { INBOX_INIT } from '../../inbox.data';\n// import { ConversationThreadProps } from '../../inbox.types';\n// import {\n//   fetchThreadMessages, selectFirstUnreadMessageID, selectLoadingMessageIDs, selectMessageMeta,\n//   selectScrollTop, selectThreadDetailByID, selectThreadMessageIDs, selectThreadUnreadCount, updateScrollTop\n// } from '../../slices';\n// import { LoadingMessageItem } from './LoadingMessageItem';\n// import { MessageItem } from './MessageItem';\n\n// export function ConversationThread({ threadRef, ...rest }: ConversationThreadProps) {\n//   const dispatch = useDispatch();\n//   const history = useHistory();\n//   const params = useParams<{ id: string }>();\n//   const paramsID = params.id === 'new' ? '' : params.id;\n//   const currentThread = useSelector(\n//     (state: RootState) => selectThreadDetailByID(state, paramsID)\n//   ) || INBOX_INIT.thread;\n\n//   const scrollTop = useSelector(\n//     (state: RootState) => selectScrollTop(state, { thread_id: paramsID })\n//   ) || 0;\n\n//   const { uuid: currentThreadID } = currentThread;\n//   const user_id = useSelector(selectUserID);\n//   const organisation_id = useSelector(selectOrganisationID);\n\n//   const threadMessageIDs = useSelector(\n//     (state: RootState) => selectThreadMessageIDs(state, currentThreadID)\n//   );\n\n//   const lastMessageRef = useRef<HTMLDivElement>(null);\n//   const messageItemRefs = threadMessageIDs.reduce(\n//     (acc: { [k: string]: RefObject<HTMLElement> }, item, index) => {\n//       if (item) {\n//         if (index === threadMessageIDs.length - 1) {\n//           acc[item] = lastMessageRef;\n//         } else {\n//           acc[item] = createRef<HTMLElement>();\n//         }\n//       }\n\n//       return acc;\n//     },\n//     {},\n//   );\n\n//   const loadingMessageIDs = useSelector(\n//     (state: RootState) => selectLoadingMessageIDs(state, { thread_id: paramsID })\n//   );\n//   const messageIDs = [\n//     ...loadingMessageIDs.map(id => ({ id, isLoading: true })),\n//     ...threadMessageIDs.map(id => ({ id, isLoading: false })),\n//   ].flat();\n\n//   const threadMessageMeta = useSelector(\n//     (state: RootState) => selectMessageMeta(state, { thread_id: currentThreadID })\n//   );\n//   const [hasMore, setHasMore] = useState(true);\n//   const [isScrollBtnDisplayed, setIsScrollBtnDisplayed] = useState(false);\n\n//   const threadMessageUnreadCount = useSelector(\n//     (state: RootState) => selectThreadUnreadCount(state, {\n//       thread_id: currentThreadID, author_id: user_id || ''\n//     })\n//   ) || 0;\n\n//   const firstUnreadMessgeID = useSelector(\n//     (state: RootState) => selectFirstUnreadMessageID(state, { thread_id: currentThreadID })\n//   );\n\n//   const fetchMoreData = () => {\n//     const { count = 0, page = 0 } = threadMessageMeta.meta || {};\n//     if (count !== 0 && Math.ceil((count / 15) - page) === 0) {\n//       return setHasMore(false);\n//     }\n\n//     return currentThreadID && currentThreadID !== 'start' && !currentThreadID.includes('unknown') && user_id\n//       && organisation_id && dispatch(fetchThreadMessages({\n//         page: page + 1,\n//         thread_id: currentThreadID,\n//       }));\n//   }\n\n//   const handleOnScroll = (st: number) => {\n//     if (threadRef && threadRef.current && lastMessageRef && lastMessageRef.current) {\n//       threadRef.current.dataset.scrollTop = st.toString();\n//       threadRef.current.dataset.currentThreadID = currentThreadID;\n\n//       const diff = lastMessageRef.current.scrollHeight + (st || 0);\n\n//       setIsScrollBtnDisplayed(diff <= 0);\n//     }\n//   }\n\n//   const handleScrollBtnClick = () => {\n//     if (threadMessageUnreadCount > 0) {\n//       if (firstUnreadMessgeID) {\n//         const view = messageItemRefs[firstUnreadMessgeID || ''];\n//         if (view && view.current) {\n//           view.current.scrollIntoView({\n//             behavior: 'smooth',\n//             block: 'center',\n//           });\n//         }\n//       }\n//     } else if (threadRef && threadRef.current) {\n//       threadRef.current.scrollTop = 0;\n//     }\n//   };\n\n//   // const [forceRerender, setForceRerender] = useState(0);\n//   // manage scroll\n//   useEffect(() => {\n//     if (threadRef && threadRef.current) {\n//       // eslint-disable-next-line @typescript-eslint/no-unused-vars\n//       const { scrollHeight, clientHeight } = threadRef.current;\n//       const diff = scrollTop + scrollHeight;\n\n//       // if (forceRerender > 0 && scrollHeight === clientHeight) {\n//       //   return setForceRerender(0);\n//       // }\n\n//       if (diff < 0) {\n//         // const nextForceRerender = forceRerender + 1;\n//         // threadRef.current.scrollTop = -(nextForceRerender * clientHeight);\n//         // return setForceRerender(nextForceRerender);\n//       }\n\n//       threadRef.current.scrollTop = 0;\n//       // if (forceRerender !== 0) {\n//       //   setForceRerender(0);\n//       // }\n//     }\n//     // }, [paramsID, scrollTop, forceRerender]);\n//     // eslint-disable-next-line react-hooks/exhaustive-deps\n//   }, [paramsID, scrollTop]);\n\n//   // fetch the conversation messages\n//   useEffect(() => {\n//     setHasMore(true);\n//     fetchMoreData();\n//     // eslint-disable-next-line react-hooks/exhaustive-deps\n//   }, [currentThreadID]);\n\n//   useEffect(() => {\n//     return history.listen(() => {\n//       if (threadRef?.current) {\n//         const {\n//           scrollTop: trScrollTop = '0', currentThreadID: trCurrentThreadID = ''\n//         } = threadRef.current.dataset || {};\n//         const scrollTop = Number(trScrollTop);\n\n//         if (trCurrentThreadID && scrollTop < 0) {\n//           dispatch(updateScrollTop({ thread_id: trCurrentThreadID, scrollTop }));\n//         }\n\n//         threadRef.current.dataset.scrollTop = '0';\n//       }\n//     })\n//     // eslint-disable-next-line react-hooks/exhaustive-deps\n//   }, [history]);\n\n//   return (\n//     <Flex\n//       overflowY=\"hidden\"\n//       flexDirection=\"column\"\n//       {...rest}\n//     >\n//       <Flex\n//         flexDirection=\"column-reverse\"\n//         overflowY=\"scroll\"\n//         flex={1}\n//         className=\"thread\"\n//         id=\"message-thread-scrollable\"\n//         pt=\"0\"\n//         px={['1rem', '1rem', '2.5rem', '2.5rem']}\n//         ref={threadRef}\n//         onScroll={(e: any) => handleOnScroll(e.target.scrollTop)}\n//       >\n//         <InfiniteScroll\n//           dataLength={messageIDs.length}\n//           next={fetchMoreData}\n//           style={{ display: 'flex', flexDirection: 'column-reverse', paddingBottom: '.75rem' }}\n//           inverse={true}\n//           hasMore={hasMore}\n//           loader={(\n//             <Box textAlign=\"center\" paddingTop=\"2rem\">\n//               <Spinner color=\"blue.500\" size=\"md\" />\n//             </Box>\n//           )}\n//           scrollableTarget=\"message-thread-scrollable\"\n//         >\n//           {messageIDs.map(({ id, isLoading }, index) => (\n//             <Box key={id} width=\"100%\" marginTop=\"1rem\" ref={messageItemRefs[id]}>\n//               {id === threadMessageMeta.firstUnreadMessageID && index !== 0 && (\n//                 <Flex marginY=\"1rem\" alignItems=\"center\">\n//                   <Box height=\"1px\" backgroundColor=\"#E2E8F0\" flex={1} />\n//                   <Text marginX=\"0.5rem\" fontSize=\".75rem\" fontStyle=\"italic\" color=\"red.500\">New</Text>\n//                   <Box height=\"1px\" backgroundColor=\"#E2E8F0\" flex={1} />\n//                 </Flex>\n//               )}\n\n//               {isLoading ? (\n//                 <LoadingMessageItem\n//                   messageRef={messageItemRefs[id]}\n//                   previousItemID={threadMessageIDs[index - 1]}\n//                   nextItemID={threadMessageIDs[index + 1]}\n//                   threadSenderID={currentThread.sender_id}\n//                   itemID={id}\n//                 />\n//               ) : (\n//                 <MessageItem\n//                   messageRef={messageItemRefs[id]}\n//                   previousItemID={threadMessageIDs[index - 1]}\n//                   nextItemID={threadMessageIDs[index + 1]}\n//                   itemID={id}\n//                   threadSenderID={currentThread.sender_id}\n//                 />\n//               )}\n//             </Box>\n//           ))}\n//         </InfiniteScroll>\n\n//         {isScrollBtnDisplayed && (\n//           <Box\n//             position=\"absolute\"\n//             bottom=\"6rem\"\n//             right={['1rem', '1rem', '2.5rem', '2.5rem']}\n//           >\n//             <IconButton\n//               aria-label=\"scroll down\"\n//               icon=\"arrow-down\"\n//               size=\"md\"\n//               borderRadius=\"50%\"\n//               onClick={handleScrollBtnClick}\n//             />\n\n//             {threadMessageUnreadCount > 0 && (\n//               <Badge\n//                 variant=\"solid\"\n//                 variantColor=\"blue\"\n//                 borderRadius=\"50%\"\n//                 position=\"absolute\"\n//                 left=\"-.25rem\"\n//               >\n//                 {threadMessageUnreadCount}\n//               </Badge>\n//             )}\n//           </Box>\n//         )}\n//       </Flex>\n//     </Flex>\n//   );\n// }\n"]},"metadata":{},"sourceType":"module"}