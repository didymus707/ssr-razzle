{"ast":null,"code":"import { useMutation, useQueryClient } from 'react-query';\nexport const useCreateMutation = ({\n  key,\n  action,\n  onError,\n  onSettled\n}) => {\n  const queryClient = useQueryClient();\n  return useMutation(action, {\n    // When mutate is called:\n    onMutate: async newItem => {\n      // Cancel any outgoing refetches (so they don't overwrite our optimistic update)\n      await queryClient.cancelQueries(key); // Snapshot the previous value\n\n      const previousItems = queryClient.getQueryData(key); // Optimistically update to the new value\n\n      if (previousItems) {\n        //@ts-ignore\n        queryClient.setQueryData(key, old => [...old, newItem]);\n      } // Return a context object with the snapshotted value\n\n\n      return {\n        previousItems\n      };\n    },\n    // If the mutation fails, use the context returned from onMutate to roll back\n    onError: (err, newItem, context) => {\n      //@ts-ignore\n      queryClient.setQueryData(key, context.previousItems);\n      onError === null || onError === void 0 ? void 0 : onError(err);\n    },\n    // Always refetch after error or success:\n    onSuccess: () => {\n      queryClient.invalidateQueries(key);\n      onSettled === null || onSettled === void 0 ? void 0 : onSettled();\n    }\n  });\n};\nexport const useUpdateMutation = ({\n  key,\n  action,\n  onError,\n  onSettled\n}) => {\n  const queryClient = useQueryClient();\n  return useMutation(action, {\n    // When mutate is called:\n    onMutate: async newItem => {\n      // Cancel any outgoing refetches (so they don't overwrite our optimistic update)\n      //@ts-ignore\n      await queryClient.cancelQueries([key, newItem.id]); // Snapshot the previous value\n      //@ts-ignore\n\n      const previousItem = queryClient.getQueryData([key, newItem.id]); // Optimistically update to the new value\n      //@ts-ignore\n\n      queryClient.setQueryData([key, newItem.id], newItem); // Return a context with the previous and new todo\n\n      return {\n        previousItem,\n        newItem\n      };\n    },\n    // If the mutation fails, use the context we returned above\n    onError: (err, newItem, context) => {\n      //@ts-ignore\n      queryClient.setQueryData([key, context.newItem.id], context.previousItem);\n      onError === null || onError === void 0 ? void 0 : onError(err);\n    },\n    // Always refetch after error or success:\n    onSuccess: newItem => {\n      //@ts-ignore\n      queryClient.invalidateQueries(['todos', newItem.id]);\n      onSettled === null || onSettled === void 0 ? void 0 : onSettled();\n    }\n  });\n};\nexport const useDeleteMutation = ({\n  key,\n  action,\n  onError,\n  onSettled\n}) => {\n  const queryClient = useQueryClient();\n  return useMutation(action, {\n    // When mutate is called:\n    onMutate: async newItem => {\n      // Cancel any outgoing refetches (so they don't overwrite our optimistic update)\n      //@ts-ignore\n      await queryClient.cancelQueries([key, newItem.id]); // Snapshot the previous value\n      //@ts-ignore\n\n      const previousItem = queryClient.getQueryData([key, newItem.id]); // Optimistically update to the new value\n      //@ts-ignore\n\n      queryClient.setQueryData(key, old => old.filter(item => item.id !== newItem.id)); // Return a context with the previous and new todo\n\n      return {\n        previousItem,\n        newItem\n      };\n    },\n    // If the mutation fails, use the context we returned above\n    onError: (err, newItem, context) => {\n      //@ts-ignore\n      queryClient.setQueryData([key, context.newItem.id], context.previousItem);\n      onError === null || onError === void 0 ? void 0 : onError(err);\n    },\n    // Always refetch after error or success:\n    onSuccess: newItem => {\n      //@ts-ignore\n      queryClient.invalidateQueries(['todos', newItem.id]);\n      onSettled === null || onSettled === void 0 ? void 0 : onSettled();\n    }\n  });\n};","map":{"version":3,"sources":["/Users/okechukwuiheagwara/Documents/Adewale/simpu/razzle/with-typescript/src/hooks/use-mutations.ts"],"names":["useMutation","useQueryClient","useCreateMutation","key","action","onError","onSettled","queryClient","onMutate","newItem","cancelQueries","previousItems","getQueryData","setQueryData","old","err","context","onSuccess","invalidateQueries","useUpdateMutation","id","previousItem","useDeleteMutation","filter","item"],"mappings":"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","sourcesContent":["import { AxiosError } from 'axios';\nimport { useMutation, useQueryClient } from 'react-query';\n\ntype MutationOptions = {\n  key: string;\n  action: any;\n  onError?(err: AxiosError): void;\n  onSettled?(): void;\n};\n\nexport const useCreateMutation = ({ key, action, onError, onSettled }: MutationOptions) => {\n  const queryClient = useQueryClient();\n  return useMutation<any, AxiosError, any, any>(action, {\n    // When mutate is called:\n    onMutate: async newItem => {\n      // Cancel any outgoing refetches (so they don't overwrite our optimistic update)\n      await queryClient.cancelQueries(key);\n\n      // Snapshot the previous value\n      const previousItems = queryClient.getQueryData(key);\n\n      // Optimistically update to the new value\n      if (previousItems) {\n        //@ts-ignore\n        queryClient.setQueryData(key, old => [...old, newItem]);\n      }\n\n      // Return a context object with the snapshotted value\n      return { previousItems };\n    },\n    // If the mutation fails, use the context returned from onMutate to roll back\n    onError: (err, newItem, context) => {\n      //@ts-ignore\n      queryClient.setQueryData(key, context.previousItems);\n      onError?.(err);\n    },\n    // Always refetch after error or success:\n    onSuccess: () => {\n      queryClient.invalidateQueries(key);\n      onSettled?.();\n    },\n  });\n};\n\nexport const useUpdateMutation = ({ key, action, onError, onSettled }: MutationOptions) => {\n  const queryClient = useQueryClient();\n  return useMutation<any, AxiosError, any, any>(action, {\n    // When mutate is called:\n    onMutate: async newItem => {\n      // Cancel any outgoing refetches (so they don't overwrite our optimistic update)\n      //@ts-ignore\n      await queryClient.cancelQueries([key, newItem.id]);\n\n      // Snapshot the previous value\n      //@ts-ignore\n      const previousItem = queryClient.getQueryData([key, newItem.id]);\n\n      // Optimistically update to the new value\n      //@ts-ignore\n      queryClient.setQueryData([key, newItem.id], newItem);\n\n      // Return a context with the previous and new todo\n      return { previousItem, newItem };\n    },\n    // If the mutation fails, use the context we returned above\n    onError: (err, newItem, context) => {\n      //@ts-ignore\n      queryClient.setQueryData([key, context.newItem.id], context.previousItem);\n      onError?.(err);\n    },\n    // Always refetch after error or success:\n    onSuccess: newItem => {\n      //@ts-ignore\n      queryClient.invalidateQueries(['todos', newItem.id]);\n      onSettled?.();\n    },\n  });\n};\n\nexport const useDeleteMutation = ({ key, action, onError, onSettled }: MutationOptions) => {\n  const queryClient = useQueryClient();\n  return useMutation<any, AxiosError, any, any>(action, {\n    // When mutate is called:\n    onMutate: async newItem => {\n      // Cancel any outgoing refetches (so they don't overwrite our optimistic update)\n      //@ts-ignore\n      await queryClient.cancelQueries([key, newItem.id]);\n\n      // Snapshot the previous value\n      //@ts-ignore\n      const previousItem = queryClient.getQueryData([key, newItem.id]);\n\n      // Optimistically update to the new value\n      //@ts-ignore\n      queryClient.setQueryData(key, old => old.filter(item => item.id !== newItem.id));\n\n      // Return a context with the previous and new todo\n      return { previousItem, newItem };\n    },\n    // If the mutation fails, use the context we returned above\n    onError: (err, newItem, context) => {\n      //@ts-ignore\n      queryClient.setQueryData([key, context.newItem.id], context.previousItem);\n      onError?.(err);\n    },\n    // Always refetch after error or success:\n    onSuccess: newItem => {\n      //@ts-ignore\n      queryClient.invalidateQueries(['todos', newItem.id]);\n      onSettled?.();\n    },\n  });\n};\n"]},"metadata":{},"sourceType":"module"}