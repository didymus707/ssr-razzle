{"ast":null,"code":"const _excluded = [\"id\"];\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport camelCase from 'lodash/camelCase';\nexport function getTableRowDataFormat(properties) {\n  const obj = {};\n  properties.forEach(element => {\n    if (element.options) {\n      obj[element.name] = {\n        value: '',\n        name: element.name,\n        type: element.type,\n        label: element.label,\n        columnId: element.id,\n        options: element.options.map(({\n          name\n        }) => ({\n          label: name,\n          value: name\n        }))\n      };\n    } else {\n      obj[element.name] = {\n        value: '',\n        name: element.name,\n        type: element.type,\n        columnId: element.id,\n        label: element.label\n      };\n    }\n  });\n  return obj;\n}\nexport function getRowValue({\n  columns,\n  rowData\n}) {\n  const result = {};\n  Object.keys(rowData).forEach(key => {\n    const columnId = rowData[key].columnId;\n\n    if (columnId) {\n      result[camelCase(key)] = _objectSpread(_objectSpread({}, rowData[key]), {}, {\n        value: columns[columnId] || ''\n      });\n    }\n  });\n  return result;\n}\nexport function convertToTableData({\n  data,\n  properties\n}) {\n  const rowData = getTableRowDataFormat(properties);\n\n  if (data) {\n    return data.map(({\n      id,\n      columns\n    }) => {\n      const data = getRowValue({\n        rowData,\n        columns\n      });\n      return _objectSpread({\n        id\n      }, data);\n    });\n  }\n}\nexport function getTableInfo(data) {\n  var _table$columns;\n\n  const {\n    rows,\n    table\n  } = data;\n  const properties = table === null || table === void 0 ? void 0 : (_table$columns = table.columns) === null || _table$columns === void 0 ? void 0 : _table$columns.map(item => _objectSpread(_objectSpread({}, item), {}, {\n    name: camelCase(item.name)\n  }));\n  return {\n    id: table === null || table === void 0 ? void 0 : table.id,\n    name: table === null || table === void 0 ? void 0 : table.name,\n    type: table === null || table === void 0 ? void 0 : table.type,\n    properties,\n    data: convertToTableData({\n      data: rows,\n      properties\n    })\n  };\n}\nexport function getRowApiValue(row) {\n  const {\n    id\n  } = row,\n        rest = _objectWithoutProperties(row, _excluded);\n\n  let result = {\n    id\n  };\n  Object.keys(rest).forEach(item => {\n    const columnId = rest[item].columnId;\n\n    if (columnId) {\n      result[columnId] = rest[item].value;\n    }\n  });\n  return result;\n}","map":{"version":3,"sources":["/Users/public1/Documents/Projects/ssr-razzle/src/app/authenticated-app/tables/tables.utils.ts"],"names":["camelCase","getTableRowDataFormat","properties","obj","forEach","element","options","name","value","type","label","columnId","id","map","getRowValue","columns","rowData","result","Object","keys","key","convertToTableData","data","getTableInfo","rows","table","item","getRowApiValue","row","rest"],"mappings":";;;;;;;;;;;;AAAA,OAAOA,SAAP,MAAsB,kBAAtB;AASA,OAAO,SAASC,qBAAT,CAAgCC,UAAhC,EAA8D;AACnE,QAAMC,GAAG,GAAG,EAAZ;AACAD,EAAAA,UAAU,CAACE,OAAX,CAAmBC,OAAO,IAAI;AAC5B,QAAIA,OAAO,CAACC,OAAZ,EAAqB;AACnBH,MAAAA,GAAG,CAACE,OAAO,CAACE,IAAT,CAAH,GAAoB;AAClBC,QAAAA,KAAK,EAAE,EADW;AAElBD,QAAAA,IAAI,EAAEF,OAAO,CAACE,IAFI;AAGlBE,QAAAA,IAAI,EAAEJ,OAAO,CAACI,IAHI;AAIlBC,QAAAA,KAAK,EAAEL,OAAO,CAACK,KAJG;AAKlBC,QAAAA,QAAQ,EAAEN,OAAO,CAACO,EALA;AAMlBN,QAAAA,OAAO,EAAED,OAAO,CAACC,OAAR,CAAgBO,GAAhB,CAAoB,CAAC;AAAEN,UAAAA;AAAF,SAAD,MAAsC;AACjEG,UAAAA,KAAK,EAAEH,IAD0D;AAEjEC,UAAAA,KAAK,EAAED;AAF0D,SAAtC,CAApB;AANS,OAApB;AAWD,KAZD,MAYO;AACLJ,MAAAA,GAAG,CAACE,OAAO,CAACE,IAAT,CAAH,GAAoB;AAClBC,QAAAA,KAAK,EAAE,EADW;AAElBD,QAAAA,IAAI,EAAEF,OAAO,CAACE,IAFI;AAGlBE,QAAAA,IAAI,EAAEJ,OAAO,CAACI,IAHI;AAIlBE,QAAAA,QAAQ,EAAEN,OAAO,CAACO,EAJA;AAKlBF,QAAAA,KAAK,EAAEL,OAAO,CAACK;AALG,OAApB;AAOD;AACF,GAtBD;AAuBA,SAAOP,GAAP;AACD;AAED,OAAO,SAASW,WAAT,CAAsB;AAC3BC,EAAAA,OAD2B;AAE3BC,EAAAA;AAF2B,CAAtB,EAMJ;AACD,QAAMC,MAAM,GAAG,EAAf;AACAC,EAAAA,MAAM,CAACC,IAAP,CAAYH,OAAZ,EAAqBZ,OAArB,CAA6BgB,GAAG,IAAI;AAClC,UAAMT,QAAQ,GAAGK,OAAO,CAACI,GAAD,CAAP,CAAaT,QAA9B;;AACA,QAAIA,QAAJ,EAAc;AACZM,MAAAA,MAAM,CAACjB,SAAS,CAACoB,GAAD,CAAV,CAAN,mCACKJ,OAAO,CAACI,GAAD,CADZ;AAEEZ,QAAAA,KAAK,EAAEO,OAAO,CAACJ,QAAD,CAAP,IAAqB;AAF9B;AAID;AACF,GARD;AASA,SAAOM,MAAP;AACD;AAED,OAAO,SAASI,kBAAT,CAA6B;AAClCC,EAAAA,IADkC;AAElCpB,EAAAA;AAFkC,CAA7B,EAMJ;AACD,QAAMc,OAAO,GAAGf,qBAAqB,CAACC,UAAD,CAArC;;AAEA,MAAIoB,IAAJ,EAAU;AACR,WAAOA,IAAI,CAACT,GAAL,CAAS,CAAC;AAAED,MAAAA,EAAF;AAAMG,MAAAA;AAAN,KAAD,KAAqB;AACnC,YAAMO,IAAI,GAAGR,WAAW,CAAC;AAAEE,QAAAA,OAAF;AAAWD,QAAAA;AAAX,OAAD,CAAxB;AACA;AAASH,QAAAA;AAAT,SAAgBU,IAAhB;AACD,KAHM,CAAP;AAID;AACF;AAED,OAAO,SAASC,YAAT,CAAuBD,IAAvB,EAA+C;AAAA;;AACpD,QAAM;AAAEE,IAAAA,IAAF;AAAQC,IAAAA;AAAR,MAAkBH,IAAxB;AACA,QAAMpB,UAAU,GAAGuB,KAAH,aAAGA,KAAH,yCAAGA,KAAK,CAAEV,OAAV,mDAAG,eAAgBF,GAAhB,CAAqBa,IAAD,oCAClCA,IADkC;AAErCnB,IAAAA,IAAI,EAAEP,SAAS,CAAC0B,IAAI,CAACnB,IAAN;AAFsB,IAApB,CAAnB;AAIA,SAAO;AACLK,IAAAA,EAAE,EAAEa,KAAF,aAAEA,KAAF,uBAAEA,KAAK,CAAEb,EADN;AAELL,IAAAA,IAAI,EAAEkB,KAAF,aAAEA,KAAF,uBAAEA,KAAK,CAAElB,IAFR;AAGLE,IAAAA,IAAI,EAAEgB,KAAF,aAAEA,KAAF,uBAAEA,KAAK,CAAEhB,IAHR;AAILP,IAAAA,UAJK;AAKLoB,IAAAA,IAAI,EAAED,kBAAkB,CAAC;AACvBC,MAAAA,IAAI,EAAEE,IADiB;AAEvBtB,MAAAA;AAFuB,KAAD;AALnB,GAAP;AAUD;AAED,OAAO,SAASyB,cAAT,CAAyBC,GAAzB,EAAmC;AACxC,QAAM;AAAEhB,IAAAA;AAAF,MAAkBgB,GAAxB;AAAA,QAAeC,IAAf,4BAAwBD,GAAxB;;AACA,MAAIX,MAAM,GAAG;AAAEL,IAAAA;AAAF,GAAb;AACAM,EAAAA,MAAM,CAACC,IAAP,CAAYU,IAAZ,EAAkBzB,OAAlB,CAA0BsB,IAAI,IAAI;AAChC,UAAMf,QAAQ,GAAGkB,IAAI,CAACH,IAAD,CAAJ,CAAWf,QAA5B;;AACA,QAAIA,QAAJ,EAAc;AACZM,MAAAA,MAAM,CAACN,QAAD,CAAN,GAAmBkB,IAAI,CAACH,IAAD,CAAJ,CAAWlB,KAA9B;AACD;AACF,GALD;AAMA,SAAOS,MAAP;AACD","sourcesContent":["import camelCase from 'lodash/camelCase'\nimport { OptionTypeBase } from 'react-select'\nimport { PropertyOptionsSchema, PropertySchema } from './components'\nimport {\n  TableContactOptions,\n  TableDataOptions,\n  TableRowDataProps\n} from './tables.types'\n\nexport function getTableRowDataFormat (properties: PropertySchema[]) {\n  const obj = {} as TableRowDataProps\n  properties.forEach(element => {\n    if (element.options) {\n      obj[element.name] = {\n        value: '',\n        name: element.name,\n        type: element.type,\n        label: element.label,\n        columnId: element.id,\n        options: element.options.map(({ name }: PropertyOptionsSchema) => ({\n          label: name,\n          value: name\n        }))\n      }\n    } else {\n      obj[element.name] = {\n        value: '',\n        name: element.name,\n        type: element.type,\n        columnId: element.id,\n        label: element.label\n      }\n    }\n  })\n  return obj\n}\n\nexport function getRowValue ({\n  columns,\n  rowData\n}: {\n  columns: OptionTypeBase\n  rowData: TableRowDataProps\n}) {\n  const result = {} as TableRowDataProps\n  Object.keys(rowData).forEach(key => {\n    const columnId = rowData[key].columnId\n    if (columnId) {\n      result[camelCase(key)] = {\n        ...rowData[key],\n        value: columns[columnId] || ''\n      }\n    }\n  })\n  return result\n}\n\nexport function convertToTableData ({\n  data,\n  properties\n}: {\n  data?: TableContactOptions[]\n  properties: PropertySchema[]\n}) {\n  const rowData = getTableRowDataFormat(properties)\n\n  if (data) {\n    return data.map(({ id, columns }) => {\n      const data = getRowValue({ rowData, columns })\n      return { id, ...data }\n    })\n  }\n}\n\nexport function getTableInfo (data: TableDataOptions) {\n  const { rows, table } = data\n  const properties = table?.columns?.map((item: any) => ({\n    ...item,\n    name: camelCase(item.name)\n  }))\n  return {\n    id: table?.id,\n    name: table?.name,\n    type: table?.type,\n    properties,\n    data: convertToTableData({\n      data: rows,\n      properties\n    })\n  }\n}\n\nexport function getRowApiValue (row: any) {\n  const { id, ...rest } = row\n  let result = { id } as any\n  Object.keys(rest).forEach(item => {\n    const columnId = rest[item].columnId\n    if (columnId) {\n      result[columnId] = rest[item].value\n    }\n  })\n  return result\n}\n"]},"metadata":{},"sourceType":"module"}