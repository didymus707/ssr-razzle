{"ast":null,"code":"const _excluded = [\"disconnected_credential\"],\n      _excluded2 = [\"id\"],\n      _excluded3 = [\"unknown\"];\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { createAction, createAsyncThunk } from '@reduxjs/toolkit';\nimport { normalize, schema } from 'normalizr';\nimport * as inboxService from '../inbox.service';\nimport { destrutureMessage, aggregate, getUnknownColumnID } from '../inbox.utils';\nimport { initializePusher, pusher } from '../../../../utils/pusher';\nimport { createRow, filterRows, sortRows, updateRow, updateTable } from '../../tables';\nimport { sortTemplatesFunc } from '../../marketing/templates/templates.utils';\nimport { loadState } from '../../../../utils';\nconst attachmentDataStruct = new schema.Entity('attachmentData', {}, {\n  idAttribute(value, attachment) {\n    return attachment.id;\n  },\n\n  processStrategy(value, attachment) {\n    return _objectSpread(_objectSpread({}, value), {}, {\n      attachment_id: attachment.id\n    });\n  }\n\n});\nconst attachmentStruct = new schema.Entity('attachments', {\n  data: attachmentDataStruct\n}, {\n  idAttribute(value, message) {\n    return value.id ? value.id : message.uuid;\n  },\n\n  processStrategy(value, message, key) {\n    let {\n      id\n    } = value;\n\n    if (!id) {\n      const index = message[key].findIndex(item => value === item);\n      id = `${message.uuid}-${index}`;\n    }\n\n    return _objectSpread(_objectSpread({}, value), {}, {\n      id,\n      message_id: message.uuid\n    });\n  }\n\n});\nconst unfurledUrlStruct = new schema.Entity('unfurledUrls', undefined, {\n  idAttribute(value, messageMeta) {\n    return messageMeta.message_id;\n  },\n\n  processStrategy(value, messageMeta) {\n    return _objectSpread(_objectSpread({}, value), {}, {\n      message_id: messageMeta.message_id\n    });\n  }\n\n});\nconst messageMetaStruct = new schema.Entity('messageMetas', {\n  unfurledUrls: [unfurledUrlStruct]\n}, {\n  idAttribute(value, message) {\n    return message.uuid;\n  },\n\n  processStrategy(value, message) {\n    return _objectSpread(_objectSpread({}, value), {}, {\n      message_id: message.uuid\n    });\n  }\n\n});\nconst addressBookStruct = new schema.Entity('addressBooks', {}, {\n  idAttribute: 'uuid'\n});\nconst platformContactStruct = new schema.Entity('platformContacts', {}, {\n  idAttribute: 'uuid'\n});\nconst customerStruct = new schema.Entity('customers', {\n  address_books: [addressBookStruct],\n  contacts: [platformContactStruct],\n  contact: platformContactStruct\n}, {\n  idAttribute: 'uuid'\n});\nconst inboxUserStruct = new schema.Entity('inboxUsers', {\n  user: customerStruct\n}, {\n  idAttribute: 'uuid'\n});\nconst notificationsStruct = new schema.Entity('notifications', {}, {\n  idAttribute: 'uuid'\n});\nconst messageStruct = new schema.Entity('messages', {\n  author: inboxUserStruct,\n  meta: messageMetaStruct,\n  attachments: [attachmentStruct],\n  notifications: [notificationsStruct]\n}, {\n  idAttribute: 'uuid'\n});\nconst connectivityStruct = new schema.Entity('connectivities', {}, {\n  idAttribute: 'uuid'\n});\nconst credentialStruct = new schema.Entity('credentials', {\n  user: customerStruct,\n  connectivities: [connectivityStruct]\n}, {\n  idAttribute: 'uuid'\n});\nconst noteStruct = new schema.Entity('notes', {}, {\n  idAttribute: 'uuid'\n});\nconst assignmentStruct = new schema.Entity('assignments', {\n  notes: [noteStruct]\n}, {\n  idAttribute: 'uuid'\n});\nconst threadStruct = new schema.Entity('threads', {\n  sender: customerStruct,\n  receiver: credentialStruct,\n  last_message: messageStruct,\n  assignments: [assignmentStruct]\n}, {\n  idAttribute: 'uuid'\n});\nconst columnStruct = new schema.Entity('columns', {}, {\n  idAttribute(value, contact) {\n    return contact.id;\n  },\n\n  processStrategy(value, contact) {\n    return _objectSpread(_objectSpread({}, value), {}, {\n      contact_id: contact.id\n    });\n  }\n\n});\nconst contactStruct = new schema.Entity('contacts', {\n  columns: columnStruct\n});\nconst assigningPayloadStruct = {\n  thread: threadStruct,\n  notifications: [notificationsStruct]\n};\nconst sendingPayloadStruct = {\n  thread: threadStruct,\n  message: messageStruct\n};\nexport const onWebSocketAssignedThread = createAction('inbox/websocket/thread_assigned');\nexport const onWebSocketNewThread = createAction('inbox/websocket/thread_new');\nexport const onWebSocketResolvedThread = createAction('inbox/websocket/thread_resolved');\nexport const onNewWebsocketEvent = createAction('inbox/websocket/event_new');\nexport const onContactListFetch = createAction('inbox/contact-list/get');\nexport const onWebSocketNewMessage = createAction('inbox/websocket/message_new');\nexport const onWebSocketNewNote = createAction('inbox/websocket/note_new');\nexport const onWebSocketWhatsAppQrCode = createAction('integration/whatsapp_web/qrcode');\nexport const onWebSocketWhatsAppQrCodeFailure = createAction('integration/whatsapp_web/qrcode-failure');\nexport const onWebSocketAccountDisconnected = createAction('integration/whatsapp_web/qrcode-failure');\nexport const onWebSocketAccountStatusChanged = createAction('integration/account/status-changed');\nexport const onWebSocketWhatsAppAccountStatusChange = createAction('integration/whatsapp_web/account/connection_status_change');\nexport const loadScrollMemory = createAsyncThunk('inbox/scrollMemory/load', () => {\n  const currentLocalState = loadState();\n  return (currentLocalState === null || currentLocalState === void 0 ? void 0 : currentLocalState.scrollMemory) || {};\n});\nexport const subscribeToWebsocket = createAsyncThunk('inbox/websocket/subscribe', (params, {\n  dispatch\n}) => {\n  const {\n    organisation_id,\n    profile_id\n  } = params;\n\n  if (!pusher) {\n    console.log('pusher connection is not set');\n    initializePusher(profile_id);\n  }\n\n  const orgChannel = pusher.subscribe(`presence_${organisation_id}`);\n\n  if (orgChannel) {\n    orgChannel.unbind();\n    orgChannel.bind('thread_new', data => {\n      const payload = normalize(data, threadStruct).entities;\n      dispatch(onNewWebsocketEvent());\n      dispatch(onWebSocketNewThread(payload));\n    }); // orgChannel.bind('thread_assigned', (data: any) => {\n    //   const {\n    //     thread: {\n    //       assignments: [{ assigner_id }],\n    //     },\n    //   } = data || {\n    //     thread: { assignments: [{ assigner_id: '' }] },\n    //   };\n    //   if (assigner_id !== profile_id) {\n    //     dispatch(onNewWebsocketEvent());\n    //   }\n    //   const payload = normalize(data, assigningPayloadStruct).entities;\n    //   dispatch(onWebSocketAssignedThread(payload));\n    // });\n\n    orgChannel.bind('thread_resolved', data => {\n      const payload = normalize(data, threadStruct).entities;\n      dispatch(onWebSocketResolvedThread(payload));\n    });\n    orgChannel.bind('whatsapp_account_connected', data => {\n      const payload = normalize(data.credential, credentialStruct).entities;\n      dispatch(onWebSocketWhatsAppAccountStatusChange(_objectSpread(_objectSpread({}, payload), {}, {\n        status: 'connected'\n      })));\n    });\n    orgChannel.bind('whatsapp_account_connection_failed', data => {\n      dispatch(onWebSocketWhatsAppQrCodeFailure(data));\n    });\n    orgChannel.bind('channel_account_disconnected', data => {\n      const {\n        disconnected_credential\n      } = data,\n            rest = _objectWithoutProperties(data, _excluded);\n\n      const payload = normalize(disconnected_credential, credentialStruct).entities;\n      dispatch(onWebSocketAccountDisconnected(_objectSpread(_objectSpread({}, payload), rest)));\n    });\n    orgChannel.bind('channel_account_status_changed', data => {\n      dispatch(onWebSocketAccountStatusChanged({\n        credentials: [data]\n      }));\n    });\n  }\n\n  const userChannel = pusher.subscribe(`private_${profile_id}`);\n\n  if (userChannel) {\n    userChannel.unbind();\n\n    const messageCallback = message => {\n      if ((message === null || message === void 0 ? void 0 : message.author_id) !== profile_id) {\n        dispatch(onNewWebsocketEvent());\n      }\n    };\n\n    userChannel.bind('message_new', messageCallback);\n    userChannel.bind('message_retry', messageCallback);\n    orgChannel.bind('message_new', messageCallback);\n  }\n\n  return organisation_id;\n});\nexport const fetchThreadsByState = createAsyncThunk('threads/fetch', async (params, {\n  dispatch\n}) => {\n  const response = await inboxService.getConversationThreads(params);\n  const {\n    threads,\n    meta\n  } = response.data;\n  const payload = normalize(threads, [threadStruct]).entities;\n  return _objectSpread(_objectSpread({}, payload), {}, {\n    meta\n  });\n});\nexport const fetchThreadByID = createAsyncThunk('threads/fetch/single', async (params, {\n  dispatch\n}) => {\n  const response = await inboxService.getThreadByID(params); //@ts-ignore\n\n  const {\n    thread\n  } = response.data;\n  const payload = normalize(thread, threadStruct).entities;\n  return payload;\n});\nexport const assignThread = createAsyncThunk('inbox/thread/assign', async params => {\n  const response = await inboxService.assignConversationThread(params);\n  const payload = normalize(response.data, assigningPayloadStruct).entities;\n  return payload;\n});\nexport const fetchContactTable = createAsyncThunk('inbox/contact/get_table', async (params, {\n  dispatch\n}) => {\n  const response = await inboxService.getContactTable();\n  const {\n    table\n  } = response.data;\n\n  if (table) {\n    const listResponse = await sortRows({\n      sorts: [{\n        name: 'Name',\n        order: 'ASC'\n      }],\n      table_id: table.id\n    });\n    const {\n      rows\n    } = listResponse.data;\n    const payload = normalize(rows, [contactStruct]).entities;\n    dispatch(onContactListFetch(payload));\n  }\n\n  return await table;\n});\nexport const searchContactList = createAsyncThunk('inbox/contact/get_list', async params => {\n  return await filterRows(params);\n});\nexport const fetchThreadAssignments = createAsyncThunk('inbox/thread/get_assignments', async params => {\n  const response = await inboxService.getConversationAssignments(params);\n  const {\n    assignments\n  } = response.data;\n  const payload = normalize(assignments, [assignmentStruct]).entities;\n  return payload;\n});\nexport const resolveThread = createAsyncThunk('inbox/thread/resolve', async params => {\n  const response = await inboxService.resolveConversationThread(params);\n  const payload = normalize(response.data, threadStruct).entities;\n  return payload;\n});\nexport const fetchThreadMessages = createAsyncThunk('inbox/thread/messages', async params => {\n  const response = await inboxService.getConversationMessages(params);\n  const {\n    messages,\n    firstUnreadMessgeID,\n    thread_id,\n    meta\n  } = response.data;\n  const payload = normalize(messages, [messageStruct]).entities;\n  return _objectSpread(_objectSpread({}, payload), {}, {\n    ui: {\n      firstUnreadMessgeID,\n      thread_id,\n      meta\n    }\n  });\n});\nexport const onMessageRead = createAction('inbox/message/on_message_read');\nexport const updateNotification = createAsyncThunk('inbox/message/update_notification', async (params, {\n  dispatch\n}) => {\n  if (['sent', 'delivered'].includes(params.status)) {\n    dispatch(onMessageRead(params));\n    await inboxService.updateMessageNotificationStatus(_objectSpread(_objectSpread({}, params), {}, {\n      notification_event: 'read'\n    }));\n  }\n});\nexport const addInboxContact = createAsyncThunk('inbox/message/send/contact/add', async params => {\n  const response = await createRow(params);\n  const {\n    row\n  } = response.data;\n  const payload = normalize(row, contactStruct).entities;\n  return _objectSpread(_objectSpread({}, payload), {}, {\n    contact_id: row.id\n  });\n});\nexport const sendMessage = createAsyncThunk('inbox/message/send', async params => {\n  const meth = params.thread_id ? inboxService.sendMessage : inboxService.startThread;\n  const response = await meth(params);\n  const {\n    message,\n    thread,\n    organisation_id,\n    sender,\n    addressBook\n  } = response.data;\n  const payload = normalize({\n    message,\n    thread: thread ? _objectSpread(_objectSpread({\n      organisation_id\n    }, thread), {}, {\n      sender: _objectSpread(_objectSpread({}, sender), {}, {\n        addressBooks: addressBook ? [addressBook] : undefined\n      })\n    }) : null\n  }, sendingPayloadStruct).entities;\n  return _objectSpread(_objectSpread({}, payload), {}, {\n    thread_id: message.thread_id,\n    message_id: message.uuid\n  });\n});\nexport const retrySendingMessage = createAsyncThunk('inbox/message/send/retry', async params => {\n  const response = await inboxService.retryMessage(params);\n  const {\n    message\n  } = response.data;\n  return {\n    messages: [message]\n  };\n});\nexport const fetchTemplates = createAsyncThunk('inbox/app-templates/fetch', async () => {\n  const response = await inboxService.getContactTemplates();\n  const {\n    templates\n  } = response.data;\n  /**\n   * sort templates based on created datetime\n   * this sort should come from API actually\n   */\n\n  const sortedTemplates = templates.sort(sortTemplatesFunc);\n  return await sortedTemplates;\n});\nexport const fetchInboxTemplates = createAsyncThunk('inbox/inbox-templates/fetch', async params => {\n  const response = await inboxService.getInboxTemplates(params);\n  return response.data;\n});\nexport const sendInboxTemplate = createAsyncThunk('inbox/inbox-templates/send', async params => {\n  const response = await inboxService.sendInboxTemplates(params);\n  const {\n    messageData\n  } = response.data;\n  return aggregate(destrutureMessage(messageData));\n});\nexport const generatePaymentLink = createAsyncThunk('inbox/payment-link/generate', async params => {\n  const response = await inboxService.generatePaymentLink(params);\n  return response.data;\n});\nexport const addConversationToPaymentLink = createAsyncThunk('inbox/payment-link/update', async params => {\n  const response = await inboxService.updatePaymentLink(params);\n  return response.data;\n});\nexport const addContact = createAsyncThunk('inbox/contact/add', async params => {\n  var _contact, _response$data, _response$data$row;\n\n  const {\n    columns,\n    contact: conts,\n    restOfTable,\n    contact_id,\n    thread_id,\n    customer_id\n  } = params;\n  let contact = conts;\n\n  if ((_contact = contact) !== null && _contact !== void 0 && _contact.unknown) {\n    let unknownColumn;\n    const tableResponse = await updateTable(_objectSpread(_objectSpread({}, restOfTable), {}, {\n      columns: columns.map(item => {\n        if (item.id === 'unknown') {\n          const {\n            id\n          } = item,\n                rest = _objectWithoutProperties(item, _excluded2);\n\n          unknownColumn = rest;\n          return rest;\n        }\n\n        return item;\n      })\n    }));\n    const {\n      table\n    } = tableResponse.data || {};\n    const unknownColumnID = getUnknownColumnID(table.columns, unknownColumn);\n\n    const {\n      unknown\n    } = contact,\n          restOfContact = _objectWithoutProperties(contact, _excluded3);\n\n    restOfContact[unknownColumnID] = unknown;\n    contact = restOfContact;\n  }\n\n  const response = contact_id ? await updateRow({\n    id: contact_id,\n    columns: contact\n  }) : await createRow({\n    columns: contact,\n    table_id: restOfTable.id\n  });\n  let address_book;\n\n  if (response !== null && response !== void 0 && (_response$data = response.data) !== null && _response$data !== void 0 && (_response$data$row = _response$data.row) !== null && _response$data$row !== void 0 && _response$data$row.id) {\n    var _addressBookResponse$;\n\n    const addressBookResponse = await inboxService.addContactToConversation({\n      customer_id,\n      contact_id: response.data.row.id\n    });\n    address_book = addressBookResponse === null || addressBookResponse === void 0 ? void 0 : (_addressBookResponse$ = addressBookResponse.data) === null || _addressBookResponse$ === void 0 ? void 0 : _addressBookResponse$.address_book;\n  }\n\n  const {\n    row,\n    table\n  } = response.data;\n  const payload = normalize(row, contactStruct).entities;\n  return _objectSpread(_objectSpread({}, payload), {}, {\n    table,\n    addressBooks: [address_book],\n    thread_id\n  });\n});\nexport const addTableColumn = createAsyncThunk('inbox/contact/addTableColumn', async params => {\n  const tableResponse = await updateTable(params);\n  return tableResponse.data;\n});\nexport const updateContact = createAsyncThunk('inbox/contact/update', async params => {\n  const {\n    contact,\n    contact_id\n  } = params;\n  const response = await updateRow({\n    id: contact_id,\n    columns: contact\n  });\n  const {\n    row,\n    table\n  } = response.data;\n  const payload = normalize(row, contactStruct).entities;\n  return _objectSpread(_objectSpread({}, payload), {}, {\n    table\n  });\n});\nexport const sendThreadNote = createAsyncThunk('inbox/notes/send', async params => {\n  const response = await inboxService.sendNote(params);\n  const {\n    comment: note\n  } = response.data;\n  return {\n    note: [note]\n  };\n});\nexport const fetchThreadNotes = createAsyncThunk('inbox/thread/notes', async params => {\n  const response = await inboxService.getNotesByThreadID(params);\n  const {\n    comments: notes,\n    meta\n  } = response.data;\n  return {\n    notes,\n    meta\n  };\n});\nexport const searchInbox = createAsyncThunk('inbox/search', async params => {\n  const response = await inboxService.searchConversations(params);\n  const {\n    data\n  } = response;\n  const {\n    entities,\n    result\n  } = normalize(data, {\n    threads: [threadStruct],\n    messages: [messageStruct]\n  });\n  return _objectSpread(_objectSpread({}, entities), {}, {\n    result\n  });\n});","map":{"version":3,"sources":["/Users/okechukwuiheagwara/Documents/Adewale/simpu/razzle/with-typescript/src/app/authenticated-app/inbox/slices/global.ts"],"names":["createAction","createAsyncThunk","normalize","schema","inboxService","destrutureMessage","aggregate","getUnknownColumnID","initializePusher","pusher","createRow","filterRows","sortRows","updateRow","updateTable","sortTemplatesFunc","loadState","attachmentDataStruct","Entity","idAttribute","value","attachment","id","processStrategy","attachment_id","attachmentStruct","data","message","uuid","key","index","findIndex","item","message_id","unfurledUrlStruct","undefined","messageMeta","messageMetaStruct","unfurledUrls","addressBookStruct","platformContactStruct","customerStruct","address_books","contacts","contact","inboxUserStruct","user","notificationsStruct","messageStruct","author","meta","attachments","notifications","connectivityStruct","credentialStruct","connectivities","noteStruct","assignmentStruct","notes","threadStruct","sender","receiver","last_message","assignments","columnStruct","contact_id","contactStruct","columns","assigningPayloadStruct","thread","sendingPayloadStruct","onWebSocketAssignedThread","onWebSocketNewThread","onWebSocketResolvedThread","onNewWebsocketEvent","onContactListFetch","onWebSocketNewMessage","onWebSocketNewNote","onWebSocketWhatsAppQrCode","onWebSocketWhatsAppQrCodeFailure","onWebSocketAccountDisconnected","onWebSocketAccountStatusChanged","onWebSocketWhatsAppAccountStatusChange","loadScrollMemory","currentLocalState","scrollMemory","subscribeToWebsocket","params","dispatch","organisation_id","profile_id","console","log","orgChannel","subscribe","unbind","bind","payload","entities","credential","status","disconnected_credential","rest","credentials","userChannel","messageCallback","author_id","fetchThreadsByState","response","getConversationThreads","threads","fetchThreadByID","getThreadByID","assignThread","assignConversationThread","fetchContactTable","getContactTable","table","listResponse","sorts","name","order","table_id","rows","searchContactList","fetchThreadAssignments","getConversationAssignments","resolveThread","resolveConversationThread","fetchThreadMessages","getConversationMessages","messages","firstUnreadMessgeID","thread_id","ui","onMessageRead","updateNotification","includes","updateMessageNotificationStatus","notification_event","addInboxContact","row","sendMessage","meth","startThread","addressBook","addressBooks","retrySendingMessage","retryMessage","fetchTemplates","getContactTemplates","templates","sortedTemplates","sort","fetchInboxTemplates","getInboxTemplates","sendInboxTemplate","sendInboxTemplates","messageData","generatePaymentLink","addConversationToPaymentLink","updatePaymentLink","addContact","conts","restOfTable","customer_id","unknown","unknownColumn","tableResponse","map","unknownColumnID","restOfContact","address_book","addressBookResponse","addContactToConversation","addTableColumn","updateContact","sendThreadNote","sendNote","comment","note","fetchThreadNotes","getNotesByThreadID","comments","searchInbox","searchConversations","result"],"mappings":"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","sourcesContent":["import { createAction, createAsyncThunk } from '@reduxjs/toolkit';\nimport { normalize, schema } from 'normalizr';\nimport { AppDispatch } from '../../../../root';\nimport * as inboxService from '../inbox.service';\nimport { destrutureMessage, aggregate, getUnknownColumnID } from '../inbox.utils';\nimport { initializePusher, pusher } from '../../../../utils/pusher';\nimport {\n  AssignmentSchema,\n  AttachmentDataSchema,\n  AttachmentSchema,\n  ContactSchema,\n  ContactColumnSchema,\n  InboxUserSchema,\n  MessageMetaSchema,\n  UnfurledUrlSchema,\n  MessageSchema,\n  NoteSchema,\n  NotificationSchema,\n  ThreadSchema,\n  CustomerSchema,\n  AddressBookSchema,\n  EntityMetaSchema,\n} from '../inbox.types';\nimport { ConnectivitySchema, CredentialSchema } from '../../channels';\nimport { createRow, filterRows, sortRows, updateRow, updateTable } from '../../tables';\nimport { sortTemplatesFunc } from '../../marketing/templates/templates.utils';\nimport { TemplateData } from '../../marketing/templates';\nimport { loadState } from '../../../../utils';\n\nconst attachmentDataStruct = new schema.Entity<AttachmentDataSchema>(\n  'attachmentData',\n  {},\n  {\n    idAttribute(value, attachment) {\n      return attachment.id;\n    },\n    processStrategy(value, attachment) {\n      return { ...value, attachment_id: attachment.id };\n    },\n  },\n);\nconst attachmentStruct = new schema.Entity<AttachmentSchema>(\n  'attachments',\n  {\n    data: attachmentDataStruct,\n  },\n  {\n    idAttribute(value, message) {\n      return value.id ? value.id : message.uuid;\n    },\n    processStrategy(value, message, key) {\n      let { id } = value;\n      if (!id) {\n        const index = message[key].findIndex((item: any) => value === item);\n        id = `${message.uuid}-${index}`;\n      }\n\n      return { ...value, id, message_id: message.uuid };\n    },\n  },\n);\nconst unfurledUrlStruct = new schema.Entity<UnfurledUrlSchema>('unfurledUrls', undefined, {\n  idAttribute(value, messageMeta) {\n    return messageMeta.message_id;\n  },\n  processStrategy(value, messageMeta) {\n    return { ...value, message_id: messageMeta.message_id };\n  },\n});\nconst messageMetaStruct = new schema.Entity<MessageMetaSchema>(\n  'messageMetas',\n  {\n    unfurledUrls: [unfurledUrlStruct],\n  },\n  {\n    idAttribute(value, message) {\n      return message.uuid;\n    },\n    processStrategy(value, message) {\n      return { ...value, message_id: message.uuid };\n    },\n  },\n);\nconst addressBookStruct = new schema.Entity<AddressBookSchema>(\n  'addressBooks',\n  {},\n  { idAttribute: 'uuid' },\n);\nconst platformContactStruct = new schema.Entity<AddressBookSchema>(\n  'platformContacts',\n  {},\n  { idAttribute: 'uuid' },\n);\nconst customerStruct = new schema.Entity<CustomerSchema>(\n  'customers',\n  {\n    address_books: [addressBookStruct],\n    contacts: [platformContactStruct],\n    contact: platformContactStruct,\n  },\n  { idAttribute: 'uuid' },\n);\nconst inboxUserStruct = new schema.Entity<InboxUserSchema>(\n  'inboxUsers',\n  { user: customerStruct },\n  { idAttribute: 'uuid' },\n);\nconst notificationsStruct = new schema.Entity<NotificationSchema>(\n  'notifications',\n  {},\n  { idAttribute: 'uuid' },\n);\nconst messageStruct = new schema.Entity<MessageSchema>(\n  'messages',\n  {\n    author: inboxUserStruct,\n    meta: messageMetaStruct,\n    attachments: [attachmentStruct],\n    notifications: [notificationsStruct],\n  },\n  { idAttribute: 'uuid' },\n);\nconst connectivityStruct = new schema.Entity<ConnectivitySchema>(\n  'connectivities',\n  {},\n  { idAttribute: 'uuid' },\n);\nconst credentialStruct = new schema.Entity<CredentialSchema>(\n  'credentials',\n  {\n    user: customerStruct,\n    connectivities: [connectivityStruct],\n  },\n  { idAttribute: 'uuid' },\n);\nconst noteStruct = new schema.Entity<NoteSchema>('notes', {}, { idAttribute: 'uuid' });\nconst assignmentStruct = new schema.Entity<AssignmentSchema>(\n  'assignments',\n  {\n    notes: [noteStruct],\n  },\n  { idAttribute: 'uuid' },\n);\nconst threadStruct = new schema.Entity<ThreadSchema>(\n  'threads',\n  {\n    sender: customerStruct,\n    receiver: credentialStruct,\n    last_message: messageStruct,\n    assignments: [assignmentStruct],\n  },\n  { idAttribute: 'uuid' },\n);\nconst columnStruct = new schema.Entity<ContactColumnSchema>(\n  'columns',\n  {},\n  {\n    idAttribute(value, contact) {\n      return contact.id;\n    },\n    processStrategy(value, contact) {\n      return { ...value, contact_id: contact.id };\n    },\n  },\n);\nconst contactStruct = new schema.Entity<ContactSchema>('contacts', { columns: columnStruct });\nconst assigningPayloadStruct = {\n  thread: threadStruct,\n  notifications: [notificationsStruct],\n};\nconst sendingPayloadStruct = {\n  thread: threadStruct,\n  message: messageStruct,\n};\n\nexport const onWebSocketAssignedThread = createAction<any>('inbox/websocket/thread_assigned');\n\nexport const onWebSocketNewThread = createAction<any>('inbox/websocket/thread_new');\n\nexport const onWebSocketResolvedThread = createAction<any>('inbox/websocket/thread_resolved');\n\nexport const onNewWebsocketEvent = createAction('inbox/websocket/event_new');\n\nexport const onContactListFetch = createAction<any>('inbox/contact-list/get');\n\nexport const onWebSocketNewMessage = createAction<any>('inbox/websocket/message_new');\n\nexport const onWebSocketNewNote = createAction<{ notes: NoteSchema[] }>('inbox/websocket/note_new');\n\nexport const onWebSocketWhatsAppQrCode = createAction<{ qrcode: string }>(\n  'integration/whatsapp_web/qrcode',\n);\n\nexport const onWebSocketWhatsAppQrCodeFailure = createAction<any>(\n  'integration/whatsapp_web/qrcode-failure',\n);\n\nexport const onWebSocketAccountDisconnected = createAction<any>(\n  'integration/whatsapp_web/qrcode-failure',\n);\n\nexport const onWebSocketAccountStatusChanged = createAction<any>(\n  'integration/account/status-changed',\n);\n\nexport const onWebSocketWhatsAppAccountStatusChange = createAction<{\n  status: 'idle' | 'connecting' | 'connected';\n}>('integration/whatsapp_web/account/connection_status_change');\n\nexport const loadScrollMemory = createAsyncThunk('inbox/scrollMemory/load', () => {\n  const currentLocalState = loadState();\n\n  return currentLocalState?.scrollMemory || {};\n});\n\nexport const subscribeToWebsocket = createAsyncThunk<string, any, { dispatch: AppDispatch }>(\n  'inbox/websocket/subscribe',\n  (params, { dispatch }) => {\n    const { organisation_id, profile_id } = params;\n\n    if (!pusher) {\n      console.log('pusher connection is not set');\n\n      initializePusher(profile_id);\n    }\n\n    const orgChannel = pusher.subscribe(`presence_${organisation_id}`);\n\n    if (orgChannel) {\n      orgChannel.unbind();\n\n      orgChannel.bind('thread_new', (data: any) => {\n        const payload = normalize(data, threadStruct).entities;\n\n        dispatch(onNewWebsocketEvent());\n        dispatch(onWebSocketNewThread(payload as any));\n      });\n\n      // orgChannel.bind('thread_assigned', (data: any) => {\n      //   const {\n      //     thread: {\n      //       assignments: [{ assigner_id }],\n      //     },\n      //   } = data || {\n      //     thread: { assignments: [{ assigner_id: '' }] },\n      //   };\n      //   if (assigner_id !== profile_id) {\n      //     dispatch(onNewWebsocketEvent());\n      //   }\n\n      //   const payload = normalize(data, assigningPayloadStruct).entities;\n      //   dispatch(onWebSocketAssignedThread(payload));\n      // });\n\n      orgChannel.bind('thread_resolved', (data: any) => {\n        const payload = normalize(data, threadStruct).entities;\n        dispatch(onWebSocketResolvedThread(payload));\n      });\n\n      orgChannel.bind('whatsapp_account_connected', (data: any) => {\n        const payload = normalize(data.credential, credentialStruct).entities;\n        dispatch(onWebSocketWhatsAppAccountStatusChange({ ...payload, status: 'connected' }));\n      });\n\n      orgChannel.bind('whatsapp_account_connection_failed', (data: any) => {\n        dispatch(onWebSocketWhatsAppQrCodeFailure(data));\n      });\n\n      orgChannel.bind('channel_account_disconnected', (data: any) => {\n        const { disconnected_credential, ...rest } = data;\n        const payload = normalize(disconnected_credential, credentialStruct).entities;\n\n        dispatch(onWebSocketAccountDisconnected({ ...payload, ...rest }));\n      });\n\n      orgChannel.bind('channel_account_status_changed', (data: any) => {\n        dispatch(onWebSocketAccountStatusChanged({ credentials: [data] }));\n      });\n    }\n\n    const userChannel = pusher.subscribe(`private_${profile_id}`);\n\n    if (userChannel) {\n      userChannel.unbind();\n\n      const messageCallback = (message: any) => {\n        if (message?.author_id !== profile_id) {\n          dispatch(onNewWebsocketEvent());\n        }\n      };\n\n      userChannel.bind('message_new', messageCallback);\n      userChannel.bind('message_retry', messageCallback);\n      orgChannel.bind('message_new', messageCallback);\n    }\n\n    return organisation_id;\n  },\n);\n\nexport const fetchThreadsByState = createAsyncThunk<any, any, { dispatch: AppDispatch }>(\n  'threads/fetch',\n  async (params, { dispatch }) => {\n    const response = await inboxService.getConversationThreads(params);\n\n    const { threads, meta } = response.data;\n    const payload = normalize(threads, [threadStruct]).entities;\n\n    return { ...payload, meta };\n  },\n);\n\nexport const fetchThreadByID = createAsyncThunk<any, any, { dispatch: AppDispatch }>(\n  'threads/fetch/single',\n  async (params, { dispatch }) => {\n    const response = await inboxService.getThreadByID(params);\n\n    //@ts-ignore\n    const { thread } = response.data;\n    const payload = normalize(thread, threadStruct).entities;\n\n    return payload;\n  },\n);\n\nexport const assignThread = createAsyncThunk<Promise<any>, any, { dispatch: AppDispatch }>(\n  'inbox/thread/assign',\n  async (params: any) => {\n    const response = await inboxService.assignConversationThread(params);\n\n    const payload = normalize(response.data, assigningPayloadStruct).entities;\n\n    return payload;\n  },\n);\n\nexport const fetchContactTable = createAsyncThunk(\n  'inbox/contact/get_table',\n  async (params, { dispatch }) => {\n    const response = await inboxService.getContactTable();\n    const { table } = response.data;\n\n    if (table) {\n      const listResponse = await sortRows({\n        sorts: [{ name: 'Name', order: 'ASC' }],\n        table_id: table.id,\n      });\n\n      const { rows } = listResponse.data;\n      const payload = normalize(rows, [contactStruct]).entities;\n      dispatch(onContactListFetch(payload));\n    }\n\n    return await table;\n  },\n);\n\nexport const searchContactList = createAsyncThunk('inbox/contact/get_list', async (params: any) => {\n  return await filterRows(params);\n});\n\nexport const fetchThreadAssignments = createAsyncThunk(\n  'inbox/thread/get_assignments',\n  async (params: any) => {\n    const response = await inboxService.getConversationAssignments(params);\n    const { assignments } = response.data;\n    const payload = normalize(assignments, [assignmentStruct]).entities;\n\n    return payload;\n  },\n);\n\nexport const resolveThread = createAsyncThunk('inbox/thread/resolve', async (params: any) => {\n  const response = await inboxService.resolveConversationThread(params);\n  const payload = normalize(response.data, threadStruct).entities;\n\n  return payload;\n});\n\nexport const fetchThreadMessages = createAsyncThunk(\n  'inbox/thread/messages',\n  async (params: any) => {\n    const response = await inboxService.getConversationMessages(params);\n    const { messages, firstUnreadMessgeID, thread_id, meta } = response.data;\n    const payload = normalize(messages, [messageStruct]).entities;\n\n    return {\n      ...payload,\n      ui: { firstUnreadMessgeID, thread_id, meta },\n    } as any;\n  },\n);\n\nexport const onMessageRead = createAction<{\n  notificationID: string;\n  status: NotificationSchema['status'];\n}>('inbox/message/on_message_read');\n\nexport const updateNotification = createAsyncThunk(\n  'inbox/message/update_notification',\n  async (params: any, { dispatch }) => {\n    if (['sent', 'delivered'].includes(params.status)) {\n      dispatch(onMessageRead(params));\n\n      await inboxService.updateMessageNotificationStatus({ ...params, notification_event: 'read' });\n    }\n  },\n);\n\nexport const addInboxContact = createAsyncThunk(\n  'inbox/message/send/contact/add',\n  async (params: any) => {\n    const response = await createRow(params);\n    const { row } = response.data;\n    const payload = normalize(row, contactStruct).entities;\n\n    return { ...payload, contact_id: row.id };\n  },\n);\n\nexport const sendMessage = createAsyncThunk('inbox/message/send', async (params: any) => {\n  const meth = params.thread_id ? inboxService.sendMessage : inboxService.startThread;\n  const response = await meth(params);\n  const { message, thread, organisation_id, sender, addressBook } = response.data;\n\n  const payload = normalize(\n    {\n      message,\n      thread: thread\n        ? {\n            organisation_id,\n            ...thread,\n            sender: {\n              ...sender,\n              addressBooks: addressBook ? [addressBook] : undefined,\n            },\n          }\n        : null,\n    },\n    sendingPayloadStruct,\n  ).entities;\n  return { ...payload, thread_id: message.thread_id, message_id: message.uuid };\n});\n\nexport const retrySendingMessage = createAsyncThunk(\n  'inbox/message/send/retry',\n  async (params: any) => {\n    const response = await inboxService.retryMessage(params);\n    const { message } = response.data;\n\n    return { messages: [message] };\n  },\n);\n\nexport const fetchTemplates = createAsyncThunk('inbox/app-templates/fetch', async () => {\n  const response = await inboxService.getContactTemplates();\n  const { templates } = response.data;\n  /**\n   * sort templates based on created datetime\n   * this sort should come from API actually\n   */\n  const sortedTemplates = templates.sort(sortTemplatesFunc);\n  return (await sortedTemplates) as TemplateData[];\n});\n\nexport const fetchInboxTemplates = createAsyncThunk(\n  'inbox/inbox-templates/fetch',\n  async (params: any) => {\n    const response = await inboxService.getInboxTemplates(params);\n\n    return response.data;\n  },\n);\n\nexport const sendInboxTemplate = createAsyncThunk(\n  'inbox/inbox-templates/send',\n  async (params: any) => {\n    const response = await inboxService.sendInboxTemplates(params);\n\n    const { messageData } = response.data;\n\n    return aggregate(destrutureMessage(messageData));\n  },\n);\n\nexport const generatePaymentLink = createAsyncThunk(\n  'inbox/payment-link/generate',\n  async (params: any) => {\n    const response = await inboxService.generatePaymentLink(params);\n\n    return response.data;\n  },\n);\n\nexport const addConversationToPaymentLink = createAsyncThunk(\n  'inbox/payment-link/update',\n  async (params: any) => {\n    const response = await inboxService.updatePaymentLink(params);\n\n    return response.data;\n  },\n);\n\nexport const addContact = createAsyncThunk('inbox/contact/add', async (params: any) => {\n  const { columns, contact: conts, restOfTable, contact_id, thread_id, customer_id } = params;\n  let contact = conts;\n\n  if (contact?.unknown) {\n    let unknownColumn;\n    const tableResponse = await updateTable({\n      ...restOfTable,\n      columns: columns.map((item: any) => {\n        if (item.id === 'unknown') {\n          const { id, ...rest } = item;\n          unknownColumn = rest;\n          return rest;\n        }\n\n        return item;\n      }),\n    });\n\n    const { table } = tableResponse.data || {};\n\n    const unknownColumnID = getUnknownColumnID(table.columns, unknownColumn);\n    const { unknown, ...restOfContact } = contact;\n    restOfContact[unknownColumnID] = unknown;\n\n    contact = restOfContact;\n  }\n\n  const response = contact_id\n    ? await updateRow({\n        id: contact_id,\n        columns: contact,\n      })\n    : await createRow({\n        columns: contact,\n        table_id: restOfTable.id,\n      });\n\n  let address_book: any;\n  if (response?.data?.row?.id) {\n    const addressBookResponse = await inboxService.addContactToConversation({\n      customer_id,\n      contact_id: response.data.row.id,\n    });\n\n    address_book = addressBookResponse?.data?.address_book;\n  }\n  const { row, table } = response.data;\n  const payload = normalize(row, contactStruct).entities;\n\n  return {\n    ...payload,\n    table,\n    addressBooks: [address_book],\n    thread_id,\n  };\n});\n\nexport const addTableColumn = createAsyncThunk(\n  'inbox/contact/addTableColumn',\n  async (params: any) => {\n    const tableResponse = await updateTable(params);\n\n    return tableResponse.data;\n  },\n);\n\nexport const updateContact = createAsyncThunk('inbox/contact/update', async (params: any) => {\n  const { contact, contact_id } = params;\n  const response = await updateRow({\n    id: contact_id,\n    columns: contact,\n  });\n\n  const { row, table } = response.data;\n  const payload = normalize(row, contactStruct).entities;\n\n  return { ...payload, table };\n});\n\nexport const sendThreadNote = createAsyncThunk('inbox/notes/send', async (params: any) => {\n  const response = await inboxService.sendNote(params);\n\n  const { comment: note } = response.data;\n\n  return { note: [note] };\n});\n\nexport const fetchThreadNotes = createAsyncThunk('inbox/thread/notes', async (params: any) => {\n  const response = await inboxService.getNotesByThreadID(params);\n  const { comments: notes, meta } = response.data;\n\n  return {\n    notes,\n    meta,\n  } as { notes: NoteSchema[]; meta: EntityMetaSchema };\n});\n\nexport const searchInbox = createAsyncThunk('inbox/search', async (params: { q: string }) => {\n  const response = await inboxService.searchConversations(params);\n  const { data } = response;\n  const { entities, result } = normalize(data, {\n    threads: [threadStruct],\n    messages: [messageStruct],\n  });\n\n  return { ...entities, result };\n});\n"]},"metadata":{},"sourceType":"module"}